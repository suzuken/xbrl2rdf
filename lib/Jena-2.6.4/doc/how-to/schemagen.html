<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>HOWTO for Jena 2 schemagen</title>
  <link rev="made" href="mailto:ian.dickinson@hp.com" />
  <meta name="generator" content="NoteTab Pro 4.92" />
  <meta name="author" content="Ian Dickinson" />
  <meta name="description" content="" />
  <meta name="keywords" content="" />
  <link href="../styles/doc.css" rel="stylesheet" type="text/css" />
  <style type="text/css">
  <!--
  td {text-align: left }
  .syntax { font: 100% "Courier new", monospace; background: #eee;  }
  .syntaxPrompt { background: #eee; }
  .xmlText { color: #33f }
  -->
  </style>
</head>

<body>

<h1>Jena schemagen HOWTO</h1>

<p>The <code>schemagen</code> provided with Jena is used to convert an OWL, DAML or RDFS vocabulary into a Java class file that contains
static constants for the terms in the vocabulary. This documents outlines the use of schemagen, and the various options and templates
that may be used to control the output.
</p>
<p> Schemagen is typically invoked from the command line or from a built script
  (such as Ant). Synopsis of the command:</p>
<pre>
java jena.schemagen -i &lt;input&gt; [-a &lt;namespaceURI&gt;] [-o &lt;output file&gt;] [-c &lt;config uri&gt;] [-e &lt;encoding&gt;] ...
</pre>
<p>Schemagen is highly configurable, either with command line options or by RDF information read from a configuration file.
<b>Many</b> other options are defined, and these are described in detail below.  Note that the <code>CLASSPATH</code> environment variable must
be set to include the Jena <code>.jar</code> libraries.
</p>
<h2>Summary of configuration options</h2>
<p>For quick reference, here is a list of all of the schemagen options (both command line and configuration file). The use of these options is explained in detail below.</p>
<table width="800" border="1" cellspacing="0" cellpadding="1">
<caption align="bottom">Table 1: schemagen options</caption>
  <tr align="left"><th style="width:190px">Command line option</th><th style="width:180px">RDF config file property</th><th style="width:430px">Meaning</th></tr>
  <tr> <td>-a &lt;uri&gt;</td> <td>sgen:namespace</td> <td>The namespace URI for the vocabulary.
    Names with this URI as prefix are automatically included in the generated vocabulary. If not specified, the base URI of the
    ontology is used as a default (but note that some ontology documents don't define a base URI).</td> </tr>
  <tr> <td>-c &lt;filename&gt;<br />-c &lt;url&gt;</td> <td>&nbsp;</td> <td>Specify an alternative config file.</td> </tr>
  <tr> <td>--classdec &lt;string&gt;</td> <td>sgen:classdec</td> <td>Additional decoration for class header (such as <code>implements</code>)</td> </tr>
  <tr> <td>--classnamesuffix &lt;string&gt;</td> <td>sgen:classnamesuffix</td> <td>Option for adding a suffix to the generated class name, e.g. "Vocab".</td> </tr>
  <tr> <td>--classSection &lt;string&gt;</td> <td>sgen:classSection</td> <td>Section declaration comment for class section.</td> </tr>
  <tr> <td>--classTemplate &lt;string&gt;</td> <td>sgen:classTemplate</td> <td>Template for writing out declarations of class resources.</td> </tr>
  <tr> <td>--daml</td> <td>sgen:daml</td> <td>Specify that the language of the source ontology is DAML+OIL.</td> </tr>
  <tr> <td>--declarations &lt;string&gt;</td> <td>sgen:declarations</td> <td>Additional declarations to add at the top of the class.</td> </tr>
  <tr> <td>--dos</td> <td>sgen:dos</td> <td>Use MSDOS-style line endings (i.e. \r\n). Default is Unix-style line endings.</td> </tr>
  <tr> <td>-e &lt;string&gt;</td> <td>sgen:encoding</td> <td>The surface syntax of the input file (e.g. RDF/XML, N3). Defaults to RDF/XML.</td> </tr>
  <tr> <td>--footer &lt;string&gt;</td> <td>sgen:footer</td> <td>Template for standard text to add to the end of the file.</td> </tr>
  <tr> <td>--header &lt;string&gt;</td> <td>sgen:header</td> <td>Template for the file header, including the class comment.</td> </tr>
  <tr> <td>-i &lt;filename&gt;<br />-i &lt;url&gt;</td> <td>sgen:input</td> <td>Specify the input document to load</td> </tr>
  <tr> <td>--include &lt;uri&gt;</td> <td>sgen:include</td> <td>Option for including non-local URI's in vocabulary</td> </tr>
  <tr> <td>--individualsSection &lt;string&gt;</td> <td>sgen:individualsSection</td> <td>Section declaration comment for individuals section.</td> </tr>
  <tr> <td>--individualTemplate &lt;string&gt;</td> <td>sgen:individualTemplate</td> <td>Template for writing out declarations of individuals.</td> </tr>
  <tr> <td>--inference</td> <td>sgen:inference</td> <td>Causes the model that loads the document prior to being processed to apply inference rules
    appropriate to the language. E.g. OWL inference rules will be used on a <code>.owl</code> file.</td> </tr>
  <tr> <td>--marker &lt;string&gt;</td> <td>sgen:marker</td> <td>Specify the marker string for substitutions, default is '%'</td> </tr>
  <tr> <td>-n &lt;string&gt;</td> <td>sgen:classname</td> <td>The name of the generated class. The default is to synthesise a name based on input document name.</td> </tr>
  <tr> <td>--noclasses</td> <td>sgen:noclasses</td> <td>Option to suppress classes in the generated vocabulary file</td> </tr>
  <tr> <td>--nocomments</td> <td>sgen:noComments</td> <td>Turn off all comment output in the generated vocabulary</td> </tr>
  <tr> <td>--noheader</td> <td>sgen:noHeader</td> <td>Prevent the output of a file header, with class comment etc.</td> </tr>
  <tr> <td>--noindividuals</td> <td>sgen:noindividuals</td> <td>Option to suppress individuals in the generated vocabulary file.</td> </tr>
  <tr> <td>--noproperties</td> <td>sgen:noproperties</td> <td>Option to suppress properties in the generated vocabulary file.</td> </tr>
  <tr> <td>-o &lt;filename&gt;<br />-o &lt;dir&gt;</td> <td>sgen:output</td>
    <td>Specify the destination for the output. If the given value evaluates to
      a directory, the generated class will be placed in that directory with a
      file name formed from the generated (or given) class name with ".java" appended.</td>
  </tr>
  <tr> <td>--nostrict</td><td>sgen:noStrict</td><td>Option to turn off strict checking for ontology classes and properties (prevents <code>ConversionExceptions</code>).</td></tr>
  <tr> <td>--ontology</td> <td>sgen:ontology</td> <td>The generated vocabulary will use the ontology API terms, in preference to RDF model API terms.</td> </tr>
  <tr> <td>--owl</td> <td>sgen:owl</td> <td>Specify that the language of the source is OWL (the default). Note that RDFS is a subset of OWL, so this setting also suffices for RDFS.</td> </tr>
  <tr> <td>--package &lt;string&gt;</td> <td>sgen:package</td> <td>Specify the Java package name and directory.</td> </tr>
  <tr> <td>--propSection &lt;string&gt;</td> <td>sgen:propSection</td> <td>Section declaration comment for properties section.</td> </tr>
  <tr> <td>--propTemplate &lt;string&gt;</td> <td>sgen:propTemplate</td> <td>Template for writing out declarations of property resources.</td> </tr>
  <tr> <td>-r &lt;uri&gt;</td> <td>&nbsp;</td> <td>Specify the uri of the root node in the RDF configuration model.</td> </tr>
  <tr> <td>--rdfs</td> <td>sgen:rdfs</td> <td>Specify that the language of the source ontology is RDFS.</td> </tr>
  <tr> <td>--strictIndividuals</td> <td>sgen:strictIndividuals</td> <td>When selecting the individuals to include in the output class, schemagen
    will normally include those individuals whose <code>rdf:type</code> is in the included namespaces for the vocabulary. However, if
  <code>strictIndividuals</code> is turned on, then all individuals in the output class must themselves have a URI in the included namespaces.</td> </tr>
  <tr> <td>--uppercase</td> <td>sgen:uppercase</td> <td>Option for mapping constant names to uppercase (like Java constants). Default is to leave the case of names unchanged.</td> </tr>
</table>

<h2>What does schemagen do?</h2>
<p>RDFS, OWL and DAML+OIL provide a very convenient means to define a
controlled vocabulary or ontology. For general ontology processing, Jena
provides various API's to allow the source files to be read in and
manipulated. However, when developing an application, it is frequently
convenient to refer to the controlled vocabulary terms directly from
Java code. This leads typically to the declaration of constants, such
as:</p>
<pre><code>
    public static final Resource A_CLASS = new ResourceImpl( "http://example.org/schemas#a-class" );
</code></pre>
<p>When these constants are defined manually, it is tedious and
error-prone to maintain them in synch with the source ontology file.
Schemagen automates the production of Java constants that correspond to
terms in an ontology document. By automating the step from source
vocabulary to Java constants, a source of error and inconsistency is
removed.</p>
<h3>Example</h3>
<p>
Perhaps the easiest way to explain the detail of what schemagen does is to show an example. Consider the following mini-RDF vocabulary:
</p>
<pre>
<code>&lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlns="http://example.org/eg#"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xml:base="http://example.org/eg"&gt;
 &nbsp;&lt;rdfs:Class rdf:ID="Dog"&gt;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;rdfs:comment&gt;A class of canine companions&lt;/rdfs:comment&gt;
 &nbsp;&lt;/rdfs:Class&gt;
 &nbsp;&lt;rdf:Property rdf:ID="petName"&gt;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;rdfs:comment&gt;The name that everyone calls a dog&lt;/rdfs:comment&gt;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;rdfs:domain rdf:resource="http://example.org/eg#Dog" /&gt;
 &nbsp;&lt;/rdf:Property&gt;
 &nbsp;&lt;rdf:Property rdf:ID="kennelName"&gt;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;rdfs:comment&gt;Posh dogs have a formal name on their KC certificate&lt;/rdfs:comment&gt;
 &nbsp;&lt;/rdf:Property&gt;
 &nbsp;&lt;Dog rdf:ID="deputy"&gt;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;rdfs:comment&gt;Deputy is a particular Dog&lt;/rdfs:comment&gt;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;kennelName&gt;Deputy Dawg of Chilcompton&lt;/kennelName&gt;
 &nbsp;&lt;/Dog&gt;
&lt;/rdf:RDF&gt;
</code></pre>
<p>We process this document with a command something like:<br />
  <code>Java jena.schemagen -i deputy.rdf -a http://example.org/eg#</code><br />
to produce the following generated class:</p>
<pre><code>
/* CVS $Id: schemagen.html,v 1.16 2010/06/11 00:08:23 ian_dickinson Exp $ */

import com.hp.hpl.jena.rdf.model.*;

/**
 * Vocabulary definitions from deputy.rdf
 * @author Auto-generated by schemagen on 01 May 2003 21:49
 */
public class Deputy {
 &nbsp;&nbsp;&nbsp;/** &lt;p&gt;The RDF model that holds the vocabulary terms&lt;/p&gt; */
 &nbsp;&nbsp;&nbsp;private static Model m_model = ModelFactory.createDefaultModel();
 &nbsp;&nbsp;&nbsp;
 &nbsp;&nbsp;&nbsp;/** &lt;p&gt;The namespace of the vocabulary as a string {@value}&lt;/p&gt; */
 &nbsp;&nbsp;&nbsp;public static final String NS = "http://example.org/eg#";
 &nbsp;&nbsp;&nbsp;
 &nbsp;&nbsp;&nbsp;/** &lt;p&gt;The namespace of the vocabulary as a resource {@value}&lt;/p&gt; */
 &nbsp;&nbsp;&nbsp;public static final Resource NAMESPACE = m_model.createResource( "http://example.org/eg#" );
 &nbsp;&nbsp;&nbsp;
 &nbsp;&nbsp;&nbsp;/** &lt;p&gt;The name that everyone calls a dog&lt;/p&gt; */
 &nbsp;&nbsp;&nbsp;public static final Property petName = m_model.createProperty( "http://example.org/eg#petName" );
 &nbsp;&nbsp;&nbsp;
 &nbsp;&nbsp;&nbsp;/** &lt;p&gt;Posh dogs have a formal name on their KC certificate&lt;/p&gt; */
 &nbsp;&nbsp;&nbsp;public static final Property kennelName = m_model.createProperty( "http://example.org/eg#kennelName" );
 &nbsp;&nbsp;&nbsp;
 &nbsp;&nbsp;&nbsp;/** &lt;p&gt;A class of canine companions&lt;/p&gt; */
 &nbsp;&nbsp;&nbsp;public static final Resource Dog = m_model.createResource( "http://example.org/eg#Dog" );
 &nbsp;&nbsp;&nbsp;
 &nbsp;&nbsp;&nbsp;/** &lt;p&gt;Deputy is a particular Dog&lt;/p&gt; */
 &nbsp;&nbsp;&nbsp;public static final Resource deputy = m_model.createResource( "http://example.org/eg#deputy" );
 &nbsp;&nbsp;&nbsp;
}
</code></pre>
<p>Some things to note in this example. All of the named classes, properties and individuals from the source document are translated to Java constants (below we show how to be more selective than this). The properties of the named resources are <i>not</i> translated: schemagen is for giving access to the names in the vocabulary or schema, not to perform a general translation of RDF to Java. The RDFS comments from the source code are translated to Javadoc comments. Finally, we no longer directly call <code>new ResourceImpl</code>: this idiom is no longer recommended by the Jena team.
</p>
<p>We noted earlier that schemagen is highly configurable. One additional argument generates a vocabulary file that uses Jena's ontology API, rather than the RDF model API. We change <code>rdfs:Class</code> to <code>owl:Class</code>, and invoke<br />
  <code>Java jena.schemagen -i deputy.rdf -b http://example.org/eg# --ontology</code><br />
  to get:</p>

  <pre><code>
/* CVs $Id: schemagen.html,v 1.16 2010/06/11 00:08:23 ian_dickinson Exp $ */

import com.hp.hpl.jena.rdf.model.*;
import com.hp.hpl.jena.ontology.*;
/**
 * Vocabulary definitions from deputy.rdf
 * @author Auto-generated by schemagen on 01 May 2003 22:03
 */
public class Deputy {
 &nbsp;&nbsp;&nbsp;/** &lt;p&gt;The ontology model that holds the vocabulary terms&lt;/p&gt; */
 &nbsp;&nbsp;&nbsp;private static OntModel m_model = ModelFactory.createOntologyModel( ProfileRegistry.OWL_LANG );
 &nbsp;&nbsp;&nbsp;
 &nbsp;&nbsp;&nbsp;/** &lt;p&gt;The namespace of the vocabulary as a string {@value}&lt;/p&gt; */
 &nbsp;&nbsp;&nbsp;public static final String NS = "http://example.org/eg#";
 &nbsp;&nbsp;&nbsp;
 &nbsp;&nbsp;&nbsp;/** &lt;p&gt;The namespace of the vocabulary as a resource {@value}&lt;/p&gt; */
 &nbsp;&nbsp;&nbsp;public static final Resource NAMESPACE = m_model.createResource( "http://example.org/eg#" );
 &nbsp;&nbsp;&nbsp;
 &nbsp;&nbsp;&nbsp;/** &lt;p&gt;The name that everyone calls a dog&lt;/p&gt; */
 &nbsp;&nbsp;&nbsp;public static final Property petName = m_model.createProperty( "http://example.org/eg#petName" );
 &nbsp;&nbsp;&nbsp;
 &nbsp;&nbsp;&nbsp;/** &lt;p&gt;Posh dogs have a formal name on their KC certificate&lt;/p&gt; */
 &nbsp;&nbsp;&nbsp;public static final Property kennelName = m_model.createProperty( "http://example.org/eg#kennelName" );
 &nbsp;&nbsp;&nbsp;
 &nbsp;&nbsp;&nbsp;/** &lt;p&gt;A class of canine companions&lt;/p&gt; */
 &nbsp;&nbsp;&nbsp;public static final OntClass Dog = m_model.createClass( "http://example.org/eg#Dog" );
 &nbsp;&nbsp;&nbsp;
 &nbsp;&nbsp;&nbsp;/** &lt;p&gt;Deputy is a particular Dog&lt;/p&gt; */
 &nbsp;&nbsp;&nbsp;public static final Individual deputy = m_model.createIndividual( Dog, "http://example.org/eg#deputy" );
 &nbsp;&nbsp;&nbsp;
}
</code></pre>

<h2>General principles</h2>
<p>In essence, schemagen will load a single vocabulary file (imports processing is switched off in DAML and OWL), and generate a Java class that contains static constants for the named classes, properties and instances of the vocabulary. Most of the generated components of the output Java file can be controlled by option flags, and formatted with a template.  Default templates are provided for all elements, so the minimum amount of necessary information is actually very small.
</p>
<p>
Options can be specified on the command line (when invoking schemagen), or may be preset in an RDF file.  Any mixture of command line and RDF option specification is permitted. Where a given option is specified both in an RDF file and on the command line, the command line setting takes precedence. Thus the options in the RDF file can be seen as defaults.
</p>
<h3>Specifying command line options</h3>
<p>To specify a command line option, add its name (and optional value) to the command line when invoking the schemagen tool. E.g:<br />
  <code>Java jena.schemagen -i myvocab.owl --ontology --uppercase</code></p>
<h3>Specifying options in an RDF file</h3>
<p>To specify an option in an RDF file, create a resource of type <code>sgen:Config</code>, with properties corresponding to the option names listed in Table 1. The following fragment shows a small options file. A complete example configuration file is shown in <a href="#appendixA">appendix A</a>.
</p>
<p> By default, schemagen will look for a configuration file named <code>schemagen.rdf</code>
  in the current directory. To specify another configuration, use the <code>-c</code>
  option with a URL to reference the configuration. Multiple configurations (i.e.
  multiple <code>sgen:Config</code> nodes) can be placed in one RDF document.
  In this case, each configuration node must be named, and the URI specified in
  the <code>-r</code> command line option. If there is no <code>-r</code> option,
  schemagen will look for a node of type <code>rdf:type sgen:Config</code>. If
  there are multiple such nodes in the model, it is indeterminate which one will
  be used. </p>
<h3 id="templates">Using templates</h3>
<p>We have several times referred to a template being used to construct part of the generated file. What is a template? Simply put, it is a fragment of output file. Some templates will be used at most once (for example the file header template), some will be used many times (such as the template used to generate a class constant). In order to make the templates adaptable to the job they're doing, before it is written out a template has <em>keyword substitution</em> performed on it.  This looks for certain keywords delimited by a pair of special characters (% by default), and replaces them with the current binding for that keyword. Some keyword bindings stay the same throughout the processing of the file, and some are dependent on the language element being processed. The substitutions are:
</p>
<table width="550" border="1" cellspacing="0" cellpadding="1">
<caption align="bottom">Table 2: Substitutable keywords in templates</caption>
  <tr> <th style="width:20%">Keyword</th> <th style="width:40%">Meaning</th> <th style="width:40%">Typical value</th> </tr>
  <tr> <td>classname</td> <td>The name of the Java class being generated</td> <td>Automatically defined from the document name, or given with the <code>-n</code> option</td> </tr>
  <tr> <td>date</td> <td>The date and time the class was generated</td> <td></td> </tr>
  <tr> <td>imports</td> <td>The Java imports for this class</td> <td></td> </tr>
  <tr> <td>nl</td> <td>The newline character for the current platform</td> <td></td> </tr>
  <tr> <td>package</td> <td>The Java package name</td>
    <td>As specified by an option. The option just gives the package name, schemagen
      turns the name into a legal Java statement.</td>
  </tr>
  <tr> <td>sourceURI</td> <td>The source of the document being processed</td> <td>As given by the <code>-i</code> option or in the config file.</td> </tr>
  <tr> <td>valclass</td> <td>The Java class of the value being defined</td> <td>E.g. Property for vocabulary properties, Resource for classes in RDFS, or OntClass for classes using the ontology API</td> </tr>
  <tr> <td>valcreator</td> <td>The method used to generate an instance of the Java representation</td> <td>E.g. <code>createResource</code> or <code>createClass</code></td> </tr>
  <tr> <td>valname</td> <td>The name of the Java constant being generated</td> <td>This is generated from the name of the resource in the source file, adjusted to be a legal Java identifier. By default, this will preserve the case of the RDF constant, but setting <code>--uppercase</code> will map all constants to upper-case names (a common convention in Java code).</td> </tr>
  <tr> <td>valtype</td> <td>The rdf:type for an individual</td> <td>The class name or URI used when creating an individual in the ontology API</td> </tr>
  <tr> <td>valuri</td> <td>The full URI of the value being defined</td> <td>From the RDF, without adjustment.</td> </tr>
</table>

<h2>Details of schemagen options</h2>
<p>We now go through each of the configuration options in detail.</p>
<p><strong>Note</strong>: for brevity, we assume a standard prefix <code>sgen</code>
  is defined for resource URI's in the schemagen namespace. The expansion for
  <code>sgen</code> is: <code>http://jena.hpl.hp.com/2003/04/schemagen#</code>,
  thus:</p>
<pre>xmlns:sgen=&quot;http://jena.hpl.hp.com/2003/04/schemagen#&quot;</pre>
<h3 id="java_ids">Note on legal Java identifiers</h3>
<p>Schemagen will attempt to ensure that all generated code will compile as legal
  Java. Occasionally, this means that identifiers from input documents, which
  are legal components of RDF URI identifiers, have to be modified to be legal
  Java identifiers. Specifically, any character in an identifier name that is
  not a legal Java identifier character will be replaced with the character '_'
  (underscore). Thus the name '<code>trading-price</code>' might become <code>'trading_price</code>'.
  In addition, Java requires that identifiers be distinct. If a name clash is
  detected (for example, <code>trading-price</code> and <code>trading+price</code>
  both map to the same Java identifier), schemagen will add disambiguators to
  the second and subsequent uses. These will be based on the role of the identifier;
  for example property names are disambiguated by appending <code>_PROPn</code>
  for increasing values of <code>n</code>. In a well-written ontology, identifiers
  are typically made distinct for clarity and ease-of-use by the ontology users,
  so the use of the disambiguation tactic is rare. Indeed, it may be taken as
  a hint that refactoring the ontology itself is desirable.</p>

<h3 id="config_file">Specifying the configuration file</h3>
<table width="650" border="0" cellspacing="0" cellpadding="1">
  <tr>
    <td style="width:140px" class="syntaxPrompt">Command line </td>
    <td class="syntax">-c &lt;<i>config-file-path</i>&gt;<br />
      -c &lt;<i>config-file-URL</i>&gt;</td>
  </tr>
  <tr>
    <td class="syntaxPrompt">Config file</td>
    <td class="syntaxPrompt">n/a</td>
  </tr>
</table>

<p>The default configuration file name is <code>schemagen.rdf</code> in the current
  directory. To specify a different configuration file, either as a file name
  on the local file system, or as a URL (e.g. an <code>http:</code> address),
  the config file location is passed with the <code>-c</code> option. If no <code>-c</code>
  option is given, and there is no configuration file in the current directory,
  schemagen will continue and use default values (plus the other command line
  options) to configure the tool. If a file name or URL is given with <code>-c</code>,
  and that file cannot be located, schemagen will stop with an error.</p>

<p>Schemagen will assume the the language encoding of the configuration file
is implied by the filename/ULRL suffix: ".n3" means N3, ".nt" means NTRIPLES,
".rdf" and ".owl" mean "RDF/XML". By default it assumes RDF/XML.
</p>

<h3 id="config_root">Specifying the configuration root in the configuration file</h3>
<table width="650" border="0" cellspacing="0" cellpadding="1">
  <tr>
    <td style="width:140" class="syntaxPrompt">Command line </td>
    <td class="syntax">-r &lt;<i>config-root-URI</i>&gt;</td>
  </tr>
  <tr>
    <td class="syntaxPrompt">Config file </td>
    <td class="syntaxPrompt">n/a</td>
  </tr>
</table>
<p>It is possible to have more than one set of configuration options in one configuration
  file. If there is only one set of configuration options, schemagen will locate
  the root by searching for a resource of rdf:type sgen:Config. If there is more
  than one, and no root is specified on the command line, it is not specified
  which set of configuration options will be used. The root URI given as a command
  line option must match exactly with the URI given in the configuration file.
  For example:</p>
<pre>Java jena.schemagen -c config/localconf.rdf -r http://example.org/sg#project1</pre>
<p>matches:</p>
<pre>...
 &lt;sgen:Config rdf:about=&quot;http://example.org/SG#project1&quot;&gt;
   ....
 &lt;/sgen:Config&gt;</pre>
<h3 id="input">Specifying the input document</h3>
<table width="650" border="0" cellspacing="0" cellpadding="1">
  <tr>
    <td style="width:140px" class="syntaxPrompt">Command line</td>
    <td  class="syntax">-i &lt;<i>input-file-path</i>&gt;<br />
      -i &lt;<i>input-URL</i>&gt;</td>
  </tr>
  <tr>
    <td style="width:140px" class="syntaxPrompt">Config file</td>
    <td  class="syntax">&lt;sgen:input rdf:resource=&quot;<i>inputURL</i>&quot; /&gt;</td>
  </tr>
</table>
<p>The only mandatory argument to schemagen is the input document to process.
  This can be specified in the configuration file, though this does, of course,
  mean that the same configuration cannot be applied to multiple different input
  files for consistency. However, by specifying the input document in the default
  configuration file, schemagen can easily be invoked with the minimum of command
  line typing. For other means of automating schemagen, see <a href="#ant">using
  schemagen with Ant</a>. </p>
<h3 id="output">Specifying the output location</h3>
<table width="650" border="0" cellspacing="0" cellpadding="1">
  <tr>
    <td style="width:140px" class="syntaxPrompt">Command line</td>
    <td  class="syntax">-o &lt;<i>input-file-path</i>&gt;<br />
      -o &lt;<i>output-dir</i>&gt;</td>
  </tr>
  <tr>
    <td style="width:140px" class="syntaxPrompt">Config file</td>
    <td  class="syntax">&lt;sgen:output rdf:datatype=&quot;&amp;xsd;string&quot;&gt;<i>
      output-path-or-dir</i>&lt;/sgen:output&gt;</td>
  </tr>
</table>
<p>Schemagen must know where to write the generated Java file. By default, the
  output is written to the standard output. Various options exist to change this.
  The output location can be specified either on the command line, or in the configuration
  file. If specified in the configuration file, the resource must be a string
  literal, denoting the file path. If the path given resolves to an existing directory,
  then it is assumed that the output will be based on the <a href="#class_name">name</a>
  of the generated class (i.e. it will be the class name with Java appended).
  Otherwise, the path is assumed to point to a file. Any existing file that has
  the given path name will be overwritten.</p>
<p>By default, schemagen will create files that have the Unix convention for line-endings
  (i.e. '\n'). To switch to DOS-style line endings, use <code>--dos</code>.</p>
<table width="650" border="0" cellspacing="0" cellpadding="1">
  <tr>
    <td style="width:140px" class="syntaxPrompt">Command line</td>
    <td  class="syntax">--dos</td>
  </tr>
  <tr>
    <td style="width:140px" class="syntaxPrompt">Config file</td>
    <td  class="syntax">&lt;sgen:dos rdf:datatype=&quot;&amp;xsd;boolean&quot;&gt;true&lt;/sgen:dos&gt;</td>
  </tr>
</table>
<p></p>
<h3 id="classname">Specifying the class name</h3>
<table width="650" border="0" cellspacing="0" cellpadding="1">
  <tr>
    <td style="width:140px" class="syntaxPrompt">Command line</td>
    <td  class="syntax">-n &lt;<i>class-name</i>&gt;</td>
  </tr>
  <tr>
    <td style="width:140px" class="syntaxPrompt">Config file</td>
    <td  class="syntax">&lt;sgen:classname rdf:datatype=&quot;&amp;xsd;string&quot;&gt;<i>
      classname</i>&lt;/sgen:classname&gt;</td>
  </tr>
</table>
<p>By default, the name of the class will be based on the name of the input file.
  Specifically, the last component of the input document's path name, with the
  prefix removed, becomes the class name. By default, the initial letter is adjusted
  to a capital to conform to standard Java usage. Thus <code>file:vocabs/trading.owl</code>
  becomes <code>Trading.java</code>. To override this default algorithm, a class
  name specified by <code>-n</code> or in the config file is used exactly as given.</p>
<p>Sometimes it is convenient to have all vocabulary files distinguished by a
  common suffix, for example <code>xyzSchema.java</code> or <code>xyzVocabs.java</code>.
  This can be achieved by the classname-suffix option:</p>
<table width="650" border="0" cellspacing="0" cellpadding="1">
  <tr>
    <td style="width:140px" class="syntaxPrompt">Command line</td>
    <td  class="syntax">--classnamesuffix &lt;<i>suffix</i>&gt;</td>
  </tr>
  <tr>
    <td style="width:140px" class="syntaxPrompt">Config file</td>
    <td  class="syntax">&lt;sgen:classnamesuffix rdf:datatype=&quot;&amp;xsd;string&quot;&gt;<i>
      suffix</i>&lt;/sgen:classnamesuffix&gt;</td>
  </tr>
</table>
<p></p>
<p>See also the <a href="#java_ids">note on legal Java identifiers</a>, which
  applies to generated class names. </p>
<p></p>
<h3 id="input">Specifying the vocabulary namespace</h3>
<table width="650" border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td style="width:140px" class="syntaxPrompt">Command line</td>
    <td class="syntax">-a &lt;<i>namespace-URI</i>&gt;</td>
  </tr>
  <tr>
    <td style="width:140px" class="syntaxPrompt">Config file</td>
    <td class="syntax">&lt;sgen:namespace rdf:datatype=&quot;&amp;xsd;string&quot;&gt;<i>namespace</i>&lt;/sgen:namespace&gt;</td>
  </tr>
</table>
<p>Since ontology files are often modularised, it is not the case that all of
  the resource names appearing in a given document are being defined by that ontology.
  They may appear simply as part of the definitions of other terms. Schemagen
  assumes that there is one primary namespace for each document, and it is names
  from that namespace that will appear in the generated Java file.</p>
<p>In an OWL or DAML+OIL ontology, this namespace is computed by finding the owl:Ontology
  or daml:Ontology element, and using its namespace as the primary namespace of
  the ontology. This may not be available (it is not, for example, a part of RDFS)
  or correct, so the namespace may be specified directly with the <code>-a</code>
  option or in the configuration file.</p>
<h3 id="output"></h3>
<p>Schemagen does not, in the present version, permit more than one primary namespace
  per generated Java class. However, constants from namespaces other than the
  primary namespace may be included in the generated Java class by the include
  option:</p>
<table width="650" border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td style="width:140px" class="syntaxPrompt">Command line</td>
    <td class="syntax">--include &lt;<i>namespace-URI</i>&gt;</td>
  </tr>
  <tr>
    <td style="width:140px" class="syntaxPrompt">Config file</td>
    <td class="syntax">&lt;sgen:include rdf:datatype=&quot;&amp;xsd;string&quot;&gt;<i>namespace</i>&lt;/sgen:include&gt;</td>
  </tr>
</table>
<p></p>
<p>The include option may repeated multiple times to include a variety of constants
  from other namespaces in the output class.</p>

<h3 id="strictIndividuals"></h3>
<p>Since OWL and RDFS ontologies may include individuals that are
  named instances of declared classes, schemagen will include individuals
  among the constants that it generates in Java. By default, an individual will be
  included if its class has a URI that is in one of the permitted namespaces for
  the vocabulary,
  even if the individual itself is not in that namespace. If the option
  <code>strictIndividuals</code> is set, individuals are <strong>only</strong> included
  if they have a URI that is in the permitted namespaces for the vocabulary.</p>
<table width="650" border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td style="width:140px" class="syntaxPrompt">Command line</td>
    <td class="syntax">--strictIndividuals</td>
  </tr>
  <tr>
    <td style="width:140px" class="syntaxPrompt">Config file</td>
    <td class="syntax">&lt;sgen:strictIndividuals /&gt;</td>
  </tr>
</table>
<p></p>

<h3 id="input_syntax">Specifying the syntax (encoding) of the input document</h3>
<table width="650" border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td style="width:140px" class="syntaxPrompt">Command line</td>
    <td class="syntax">-e &lt;<i>encoding</i>&gt;</td>
  </tr>
  <tr>
    <td style="width:140px" class="syntaxPrompt">Config file</td>
    <td class="syntax">&lt;sgen:encoding rdf:datatype=&quot;&amp;xsd;string&quot;&gt;<i>encoding</i>&lt;/sgen:encoding&gt;</td>
  </tr>
</table>

<p>Jena can parse a number of different presentation syntaxes for RDF documents,
  including RDF/XML, N3 and NTRIPLE. By default, the encoding will be derived
  from the name of the input document (e.g. a document <code>xyz.n3</code> will
  be parsed in N3 format), or, if the extension is non-obvious the default is
  RDF/XML. The encoding, and hence the parser, to use on the input document may
  be specified by the encoding configuration option.</p>

<h3 id="ontology">Choosing the style of the generated class: ontology or plain RDF</h3>
<table width="650" border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td style="width:140px" class="syntaxPrompt">Command line</td>
    <td class="syntax">--ontology</td>
  </tr>
  <tr>
    <td style="width:140px" class="syntaxPrompt">Config file</td>
    <td class="syntax">&lt;sgen:ontology rdf:datatype=&quot;&amp;xsd;boolean&quot;&gt;<i>true
      or false</i>&lt;/sgen:ontology&gt;</td>
  </tr>
</table>
<p>By default, the Java class generated by schemagen will generate constants that
  are plain RDF Resource, Property or Literal constants. When working with OWL,
  DAML, or RDFS ontologies, it may be more convenient to have constants that are OntClass,
  ObjectProperty, DatatypeProperty and Individual Java objects. To generate these
  ontology constants, rather than plain RDF constants, set the ontology configuration
  option. </p>
<p>Furthermore, since Jena can handle input ontologies in DAML+OIL, OWL (the default), and RDFS,
  it is necessary to be able to specify which language is being processed. This
  will affect both the parsing of the input documents, and the language profile
  selected for the constants in the generated Java class.</p>
<table width="650" border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td style="width:140px" class="syntaxPrompt">Command line</td>
    <td class="syntax">--daml</td>
  </tr>
  <tr>
    <td style="width:140px" class="syntaxPrompt">Config file</td>
    <td class="syntax">&lt;sgen:daml rdf:datatype=&quot;&amp;xsd;boolean&quot;&gt;true&lt;/sgen:daml&gt;</td>
  </tr>
</table>
<p></p>
<table width="650" border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td style="width:140px" class="syntaxPrompt">Command line</td>
    <td class="syntax">--owl</td>
  </tr>
  <tr>
    <td style="width:140px" class="syntaxPrompt">Config file</td>
    <td class="syntax">&lt;sgen:owl rdf:datatype=&quot;&amp;xsd;boolean&quot;&gt;true&lt;/sgen:owl&gt;</td>
  </tr>
</table>
<p></p>
<table width="650" border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td style="width:140px" class="syntaxPrompt">Command line</td>
    <td class="syntax">--rdfs</td>
  </tr>
  <tr>
    <td style="width:140px" class="syntaxPrompt">Config file</td>
    <td class="syntax">&lt;sgen:rdfs rdf:datatype=&quot;&amp;xsd;boolean&quot;&gt;true&lt;/sgen:owl&gt;</td>
  </tr>
</table>
<p>Prior to Jena 2.2, schemagen used a Jena model to load the input document that also applied
  some <em>rules of inference</em> to the input data. So, for example, a resource that is mentioned as
  the <code>owl:range</code> of a property can be inferred to be <code>rdf:type&nbsp;owl:Class</code>,
  and hence listed in the class constants in the generated Java class, even if
  that fact is not directly asserted in the input model.
  From Jena 2.2 onwards, this option is now <strong>off by default</strong>.
  If correct handling of an input document by schemagen requires the use of inference rules, this must
  be specified by the <code>inference</code> option. In particular, some DAML+OIL input files may
  require the use of this option, to ensure that synonyms such as <code>daml:Class</code> and <code>rdfs:Class</code>
  are recognised correctly.</p>
<p></p>
<table width="650" border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td style="width:140px" class="syntaxPrompt">Command line</td>
    <td class="syntax">--inference</td>
  </tr>
  <tr>
    <td style="width:140px" class="syntaxPrompt">Config file</td>
    <td class="syntax">&lt;sgen:inference rdf:datatype=&quot;&amp;xsd;boolean&quot;&gt;true&lt;/sgen:owl&gt;</td>
  </tr>
</table>
<p></p>
  <h3 id="package">Specifying the Java package</h3>
<table width="650" border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td style="width:140px" class="syntaxPrompt">Command line</td>
    <td class="syntax">--package &lt;<i>package-name</i>&gt;</td>
  </tr>
  <tr>
    <td style="width:140px" class="syntaxPrompt">Config file</td>
    <td class="syntax">&lt;sgen:package rdf:datatype=&quot;&amp;xsd;string&quot;&gt;<i>package-name</i>&lt;/sgen:package&gt;</td>
  </tr>
</table>
<p>By default, the Java class generated by schemagen will not be in a Java package.
  Set the package configuration option to specify the Java package name.
  <strong>Change from Jena 2.6.4-SNAPSHOT onwards:</strong>
  Setting the package name will affect the directory into which the generated
  class will be written: directories will be appended to the <a href="#output">output
  directory</a> to match the Java package.</p>
<h3 id="classdec">Additional decorations on the main class declaration</h3>
<table width="650" border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td style="width:140px" class="syntaxPrompt">Command line</td>
    <td class="syntax">--classdec &lt;<i>class-declaration</i>&gt;</td>
  </tr>
  <tr>
    <td style="width:140px" class="syntaxPrompt">Config file</td>
    <td class="syntax">&lt;sgen:classdec rdf:datatype=&quot;&amp;xsd;string&quot;&gt;<i>class-declaration</i>&lt;/sgen:classdec&gt;</td>
  </tr>
</table>
<p>In some applications, it may be convenient to add additional information to
  the declaration of the Java class, for example that the class implements a given
  interface (such as <code>java.lang.Serializable</code>). Any string given as
  the value of the class-declaration option will be written immediately after
  &quot;<code>public&nbsp;class&nbsp;<i>ClassName</i></code>&quot;.</p>
<h3 id="declarations">Adding general declarations within the generated class</h3>
<table width="650" border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td style="width:140px" class="syntaxPrompt">Command line</td>
    <td class="syntax">--declarations &lt;<i>declarations</i>&gt;</td>
  </tr>
  <tr>
    <td style="width:140px" class="syntaxPrompt">Config file</td>
    <td class="syntax">&lt;sgen:declarations rdf:datatype=&quot;&amp;xsd;string&quot;&gt;<i>declarations</i>&lt;/sgen:declarations&gt;</td>
  </tr>
</table>
<p>Some more complex vocabularies may require access to static constants, or other
  Java objects or factories to fully declare the constants defined by the given
  templates. Any text given by the declarations option will be included in the
  generated class after the class declaration but before the body of the declared
  constants. The value of the option should be fully legal Java code (though the
  <a href="#templates">template</a> substitutions will be performed on the code).
  Although this option can be declared as a command line option, it is typically
  easier to specify as a value in a configuration options file.</p>
<h3 id="omitting_sections">Omitting sections of the generated vocabulary</h3>
<table width="650" border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td style="width:140px" class="syntaxPrompt">Command line</td>
    <td class="syntax">--noclasses<br />
      --noproperties<br />
      --noindividuals </td>
  </tr>
  <tr>
    <td style="width:140px" class="syntaxPrompt">Config file</td>
    <td class="syntax">&lt;sgen:noclassses rdf:datatype=&quot;&amp;xsd;boolean&quot;&gt;true&lt;/sgen:noclassses&gt;<br />
      &lt;sgen:noproperties rdf:datatype=&quot;&amp;xsd;boolean&quot;&gt;true&lt;/sgen:noproperties&gt;<br />
      &lt;sgen:noindividuals rdf:datatype=&quot;&amp;xsd;boolean&quot;&gt;true&lt;/sgen:noindividuals&gt;
    </td>
  </tr>
</table>
<p>By default, the vocabulary class generated from a given ontology will include
  constants for each of the included classes, properties and individuals in the
  ontology. To omit any of these groups, use the corresponding <i>noXYZ</i> configuration
  option. For example, specifying <code>--noproperties</code> means that the generated
  class will not contain any constants corresponding to predicate names from the
  ontology, irrespective of what is in the input document.</p>
<h3 id="section_headings">Section header comments</h3>
<table width="650" border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td style="width:140px" class="syntaxPrompt">Command line</td>
    <td class="syntax">--classSection <i>&lt;section heading&gt;</i><br />
      --propSection<i> &lt;section heading&gt;</i><br />
      --individualSection <i>&lt;section heading</i>&gt;<br />
      --header <i>&lt;file header section&gt;</i><br />
      --footer <i>&lt;file footer section&gt;</i></td>
  </tr>
  <tr>
    <td style="width:140px" class="syntaxPrompt">Config file</td>
    <td class="syntax">&lt;sgen:classSection rdf:datatype=&quot;&amp;xsd;string&quot;&gt;<i>section
      heading </i>&lt;/sgen:classSection&gt;<br />
      &lt;sgen:propSection rdf:datatype=&quot;&amp;xsd;string&quot;&gt;<i>section
      heading</i>&lt;/sgen:propSection&gt;<br />
      &lt;sgen:individualSection rdf:datatype=&quot;&amp;xsd;string&quot;&gt;<i>section
      heading</i>&lt;/sgen:individualSection&gt; <br />
      &lt;sgen:header rdf:datatype=&quot;&amp;xsd;string&quot;&gt;<i>file header</i>&lt;/sgen:header&gt;
      <br />
      &lt;sgen:footer rdf:datatype=&quot;&amp;xsd;string&quot;&gt;<i>file footer</i>&lt;/sgen:footer&gt;</td>
  </tr>
</table>
<p>Some coding styles use block comments to delineate different sections of a
  class. These options allow the introduction of arbitrary Java code, though typically
  this will be a comment block, at the head of the sections of class constant
  declarations, property constant declarations, and individual constant declarations.</p>
<h2 id="ant">Using schemagen with Ant</h2>
<p><a href="http://ant.apache.org/">Apache Ant</a> is a tool for automating
  build steps in Java (and other language) projects. For example, it is the tool
  used to compile the Jena sources to the jena.jar file, and to prepare the Jena
  distribution prior to download. Although it would be quite possible to create
  an Ant <i>taskdef</i> to automate the production of Java classes from input
  vocabularies, we have not yet done this. Nevertheless, it is straightforward
  to use schemagen from an ant build script, by making use of Ant's built-in Java
  task, which can execute an arbitrary Java program.</p>
<p>The following example shows a complete ant target definition for generating
  ExampleVocab.java from example.owl. It ensures that the generation step is only
  performed when example.owl has been updated more recently than ExampleVocab.java
  (e.g. if the definitions in the owl file have recently been changed).</p>
<pre>
  &lt;!-- properties --&gt;
  &lt;<b>property</b> name=&quot;vocab.dir&quot;       value=&quot;src/org/example/vocabulary&quot; /&gt;
  &lt;<b>property</b> name=&quot;vocab.template&quot;  value=&quot;${rdf.dir}/exvocab.rdf&quot; /&gt;
  &lt;<b>property</b> name=&quot;vocab.tool&quot;      value=&quot;jena.schemagen&quot; /&gt;

  &lt;!-- Section: vocabulary generation --&gt;
  &lt;<b>target</b> name=&quot;vocabularies&quot; depends=&quot;exVocab&quot; /&gt;

  &lt;<b>target</b> name=&quot;exVocab.check&quot;&gt;
    &lt;<b>uptodate</b>
       property=&quot;exVocab.nobuild&quot;
       srcFile=&quot;${rdf.dir}/example.owl&quot;
       targetFile=&quot;${vocab.dir}/ExampleVocab.java&quot; /&gt;
  &lt;/<b>target</b>&gt;

  &lt;<b>target</b> name=&quot;exVocab&quot; depends=&quot;exVocab.check&quot; unless=&quot;exVocab.nobuild&quot;&gt;
    &lt;<b>Java</b> classname=&quot;${vocab.tool}&quot; classpathref=&quot;classpath&quot; fork=&quot;yes&quot;&gt;
      &lt;arg value=&quot;-i&quot; /&gt;
      &lt;arg value=&quot;file:${rdf.dir}/example.owl&quot; /&gt;
      &lt;arg value=&quot;-c&quot; /&gt;
      &lt;arg value=&quot;${vocab.template}&quot; /&gt;
      &lt;arg value=&quot;--classnamesuffix&quot; /&gt;
      &lt;arg value=&quot;Vocab&quot; /&gt;
      &lt;arg value=&quot;--include&quot; /&gt;
      &lt;arg value=&quot;http://example.org/2004/01/services#&quot; /&gt;
      &lt;arg value=&quot;--ontology&quot; /&gt;
    &lt;/<b>Java</b>&gt;
  &lt;/<b>target</b>&gt;
</pre>
<p>Clearly it is up to each developer to find the appropriate balance between
  options that are specified via the command line options, and those that are
  specified in the configuration options file (<code>exvocab.rdf</code> in the
  above example). This is not the only, nor necessarily the &quot;right&quot;
  way to use schemagen from Ant, but if it points readers in the appropriate direction
  to produce a custom target for their own application it will have served its
  purpose.</p>
<h2 id="appendixA">Appendix A: Complete example configuration file</h2>
<p>The source of this example is provided in the Jena download as <code>etc/schemagen.rdf</code>.
  For clarity, RDF/XML text is highlighted in <span class="xmlText">blue</span>.</p>

  <pre>
<code><span class="xmlText">&lt;?xml version='1.0'?&gt;

&lt;!DOCTYPE rdf:RDF [
 &nbsp;&nbsp;&nbsp;&lt;!ENTITY jena &nbsp;&nbsp;&nbsp;'http://jena.hpl.hp.com/'&gt;

 &nbsp;&nbsp;&nbsp;&lt;!ENTITY rdf &nbsp;&nbsp;&nbsp;&nbsp;'http://www.w3.org/1999/02/22-rdf-syntax-ns#'&gt;
 &nbsp;&nbsp;&nbsp;&lt;!ENTITY rdfs &nbsp;&nbsp;&nbsp;'http://www.w3.org/2000/01/rdf-schema#'&gt;
 &nbsp;&nbsp;&nbsp;&lt;!ENTITY owl &nbsp;&nbsp;&nbsp;&nbsp;'http://www.w3.org/2002/07/owl#'&gt;
 &nbsp;&nbsp;&nbsp;&lt;!ENTITY xsd &nbsp;&nbsp;&nbsp;&nbsp;'http://www.w3.org/2001/XMLSchema#'&gt;
 &nbsp;&nbsp;&nbsp;&lt;!ENTITY base &nbsp;&nbsp;&nbsp;'&amp;jena;2003/04/schemagen'&gt;
 &nbsp;&nbsp;&nbsp;&lt;!ENTITY sgen &nbsp;&nbsp;&nbsp;'&amp;base;#'&gt;
]&gt;

&lt;rdf:RDF
 &nbsp;xmlns:rdf &nbsp;&nbsp;="&amp;rdf;"
 &nbsp;xmlns:rdfs &nbsp;="&amp;rdfs;"
 &nbsp;xmlns:owl &nbsp;&nbsp;="&amp;owl;"
 &nbsp;xmlns:sgen  ="&amp;sgen;"
 &nbsp;xmlns &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;="&amp;sgen;"
 &nbsp;xml:base &nbsp;&nbsp;&nbsp;="&amp;base;"
&gt;</span>

&lt;!--
    Example schemagen configuration for use with jena.schemagen
 &nbsp;&nbsp;&nbsp;Not all possible options are used in this example, see Javadoc and Howto for full details.

    Author: Ian Dickinson, mailto:ian.dickinson@hp.com
    CVs: &nbsp;&nbsp;&nbsp;$Id: schemagen.html,v 1.16 2010/06/11 00:08:23 ian_dickinson Exp $
--&gt;

<span class="xmlText">&lt;sgen:Config&gt;
 &nbsp;&nbsp;&nbsp;&lt;!-- specifies that the &nbsp;source document uses OWL --&gt;
 &nbsp;&nbsp;&nbsp;&lt;sgen:owl rdf:datatype="&amp;xsd;boolean"&gt;</span>true<span class="xmlText">&lt;/sgen:owl&gt;

 &nbsp;&nbsp;&nbsp;&lt;!-- specifies that we want the generated vocab to use OntClass, OntProperty, etc, not Resource and Property --&gt;
 &nbsp;&nbsp;&nbsp;&lt;sgen:ontology rdf:datatype="&amp;xsd;boolean"&gt;</span>true<span class="xmlText">&lt;/sgen:ontology&gt;

 &nbsp;&nbsp;&nbsp;&lt;!-- specifies that we want names mapped to uppercase (as standard Java constants) --&gt;
 &nbsp;&nbsp;&nbsp;&lt;sgen:uppercase rdf:datatype="&amp;xsd;boolean"&gt;</span>true<span class="xmlText">&lt;/sgen:uppercase&gt;

 &nbsp;&nbsp;&nbsp;&lt;!-- append Vocab to class name, so input beer.owl becomes BeerVocab.java --&gt;
 &nbsp;&nbsp;&nbsp;&lt;sgen:classnamesuffix rdf:datatype="&amp;xsd;string"&gt;</span>Vocab<span class="xmlText">&lt;/sgen:classnamesuffix&gt;

 &nbsp;&nbsp;&nbsp;&lt;!-- the Java package that the vocabulary is in --&gt;
 &nbsp;&nbsp;&nbsp;&lt;sgen:package rdf:datatype="&amp;xsd;string"&gt;</span>com.example.vocabulary<span class="xmlText">&lt;/sgen:package&gt;

 &nbsp;&nbsp;&nbsp;&lt;!-- the directory or file to write the results out to --&gt;
 &nbsp;&nbsp;&nbsp;&lt;sgen:output rdf:datatype="&amp;xsd;string"&gt;</span>src/com/example/vocabulary<span class="xmlText">&lt;/sgen:output&gt;

 &nbsp;&nbsp;&nbsp;&lt;!-- the template for the file header --&gt;
&lt;sgen:header rdf:datatype="&amp;xsd;string"&gt;</span>/*****************************************************************************
 * Source code information
 * -----------------------
 * Original author &nbsp;&nbsp;&nbsp;Jane Smart, example.com
 * Author email &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jane.smart@example.com
 * Package &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@package@
 * Web site &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@website@
 * Created &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%date%
 * Filename &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$RCSfile: schemagen.html,v $
 * Revision &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$Revision: 1.16 $
 * Release status &nbsp;&nbsp;&nbsp;&nbsp;@releaseStatus@ $State: Exp $
 *
 * Last modified on &nbsp;&nbsp;$Date: 2010/06/11 00:08:23 $
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;by &nbsp;&nbsp;$Author: ian_dickinson $
 *
 * @copyright@
 *****************************************************************************/


// Package
///////////////////////////////////////
%package%


// Imports
///////////////////////////////////////
%imports%



/**
 * Vocabulary definitions from %sourceURI%
 * @author Auto-generated by schemagen on %date%
 */&lt;<span class="xmlText">/sgen:header&gt;

&lt;!-- the template for the file footer (note @footer@ is an Ant-ism, and will not be processed by SchemaGen) --&gt;
&lt;sgen:footer rdf:datatype="&amp;xsd;string"&gt;</span>
/*
@footer@
*/
<span class="xmlText">&lt;/sgen:footer&gt;

&lt;!-- template for extra declarations at the top of the class file --&gt;
&lt;sgen:declarations rdf:datatype="&amp;xsd;string"&gt;</span>
 &nbsp;&nbsp;&nbsp;/** Factory for generating symbols */
 &nbsp;&nbsp;&nbsp;private static KsValueFactory s_vf = new DefaultValueFactory();
<span class="xmlText">&lt;/sgen:declarations&gt;

&lt;!-- template for introducing the properties in the vocabulary --&gt;
&lt;sgen:propSection rdf:datatype="&amp;xsd;string"&gt;</span>
 &nbsp;&nbsp;&nbsp;// Vocabulary properties
 &nbsp;&nbsp;&nbsp;///////////////////////////
<span class="xmlText">&lt;/sgen:propSection&gt;

&lt;!-- template for introducing the classes in the vocabulary --&gt;
&lt;sgen:classSection rdf:datatype="&amp;xsd;string"&gt;</span>
 &nbsp;&nbsp;&nbsp;// Vocabulary classes
 &nbsp;&nbsp;&nbsp;///////////////////////////
<span class="xmlText">&lt;/sgen:classSection&gt;

&lt;!-- template for introducing the individuals in the vocabulary --&gt;
&lt;sgen:individualsSection rdf:datatype="&amp;xsd;string"&gt;</span>
 &nbsp;&nbsp;&nbsp;// Vocabulary individuals
 &nbsp;&nbsp;&nbsp;///////////////////////////
<span class="xmlText">&lt;/sgen:individualsSection&gt;

&lt;!-- template for doing fancy declarations of individuals --&gt;
&lt;sgen:individualTemplate rdf:datatype="&amp;xsd;string"&gt;</span>public static final KsSymbol %valname% = s_vf.newSymbol( "%valuri%" );

 &nbsp;&nbsp;&nbsp;/** Ontology individual corresponding to {@link #%valname%} */
 &nbsp;&nbsp;&nbsp;public static final %valclass% _%valname% = m_model.%valcreator%( %valtype%, "%valuri%" );
<span class="xmlText">&lt;/sgen:individualTemplate&gt;

&lt;/sgen:Config&gt;

&lt;/rdf:RDF&gt;</span>
</code></pre>

<hr />
<p><small>CVS $Id: schemagen.html,v 1.16 2010/06/11 00:08:23 ian_dickinson Exp $</small></p>
</body>
</html>
